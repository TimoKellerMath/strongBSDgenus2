// Determine regular model at p=2 of curve found by Sam Frengley

P<x> := PolynomialRing(Rationals());

// The curve is given by  y^2 = f(x)
f := -10*x^6 + 100*x^5 - 320*x^4 + 400*x^3 - 380*x^2 + 200*x - 40;

// Set up polynomial ring in four variables for the computations
P4<u,v,w,z> := PolynomialRing(Rationals(), 4);
P4F2 := PolynomialRing(GF(2), 4);
AssignNames(~P4F2, ["u", "v", "w", "z"]);

// Replace factors of 2 in coefficients by expr
function subs(expr, pol)
  cs, ms := CoefficientsAndMonomials(pol);
  return &+[Parent(pol)|(expr/2)^Valuation(cs[i], 2)*cs[i]*ms[i] : i in [1..#ms]];
end function;

// replace (y, x, 2) --> (u, v, w)
F := subs(w, u^2 - Evaluate(f, v));
// keep track of p = 2
p := subs(w, P4!2);

// extract components of special fiber of a chart
function special_fiber(F, p)
  fp := [e : e in Factorization(p) | e[1] in [u,v,w,z]];
  result := [Parent(<1, [P4F2.1]>)|];
  for pair in fp do
    var, e := Explode(pair);
    // set var to zero
    subst := [u,v,w,z]; subst[Position(subst, var)] := 0;
    fs := Factorization(P4F2!Evaluate(F, subst));
    result cat:= [<e*fe[2], [P4F2!var, fe[1]]> : fe in fs];
  end for;
  return result;
end function;

// check regularity at an ideal generated by a subset of the variables
function check_reg(F, vars)
  cofs := [F];
  for v in vars do
    // want [ [1]F, [v1]F, [v2]F, ... ] considering F in Q[other_vars][vars]
    cofs := [Coefficient(cofs[1], v, 0), Coefficient(cofs[1], v, 1)]
              cat [Coefficient(c, v, 0) : c in cofs[2..#cofs]];
  end for;
  ChangeUniverse(~cofs, P4F2);
  assert cofs[1] eq 0; // want a subvariety of the special fiber
  return cofs[2..#cofs];
end function;

// blow up at an ideal generated by a subset of the variables u, v, w (use z as the new variable)
function blow_up(F, p, vars)
  assert Degree(F, z) eq 0; // make sure F does not involve z
  deg := func<pol | &+[Degree(pol, var) : var in vars]>;
  mindeg := Min([deg(m) : m in Monomials(F)]);
  subst := [u,v,w,0]; for var in vars do subst[Position(subst, var)] *:= z; end for;
  return ExactQuotient(Evaluate(F, subst), z^mindeg), Evaluate(p, subst);
end function;

special_fiber(F, p);
// --> [ <2, [ w, u ]> ], component A
check_reg(F, [u, w]);
// --> [ v^6, 0 ], so non-regular only at v = 0
// (can check that point at infinity is regular)
F1, p1 := blow_up(F, p, [u, v, w]);
// coordinates (u : v : w), z

special_fiber(F1, p1);
// --> [ <2, [ z, u ]>, <2, [ w, u ]> ]
// new B, A
// check regularity along B
check_reg(F1, [u, z]);
// --> [ w^3, 0 ], so non-regular only at w = 0, which is the intersection point with A
// on A, can take v = 1 (on B, coord. is (v : w), can take v = 1 near w = 0)
// so set v = 1 and replace z by v
F1a := Evaluate(F1, [u,1,w,v]); p1a := Evaluate(p1, [u,1,w,v]);
// B: u = v = 0,  A: u = w = 0
F2, p2 := blow_up(F1a, p1a, [u, v, w]);
// coordinates (u : v : w), z

special_fiber(F2, p2);
// --> [ <4, [ z, u ]>, <2, [ w, u ]>, <2, [ v, u ]> ]
// new C, A, B
check_reg(F2, [u, z]);
// --> [ 0, 0 ], so all of C is non-regular --> blow it up

// first chart: v = 1
F2a := Evaluate(F2, [u,1,w,v]); p2a := Evaluate(p2, [u,1,w,v]);
// C: u = v = 0, A: u = w = 0
F3v, p3v := blow_up(F2a, p2a, [u, v]);
// have coordinates (u : v), w, z
// but v = 0 implies u = 0, so can take v = 1
F3va := Evaluate(F3v, [u,1,w,v]); p3va := Evaluate(p3v, [u,1,w,v]);
// A: u = w = 0

special_fiber(F3va, p3va);
// --> [ <2, [ w, u ]>, <2, [ v, u^2 + w^3 + w^2 ]> ]
// A, C'
P4F2!Coefficient(F3va, v, 0);
// --> u^2 + w^3 + w^2
// so regular unless perhaps have singular point on component
// only singularity is at (u, w) = (0, 0)
check_reg(F3va, [u, v, w]);
// --> [ 0, 0, 0 ], so non-regular

// second chart: w = 1
F2b := Evaluate(F2, [u,v,1,w]); p2b := Evaluate(p2, [u,v,1,w]);
// C: u = w = 0, B: u = v = 0
F3w, p3w := blow_up(F2b, p2b, [u, w]);
// have coordinates (u : w), v, z
// but w = 0 implies u = 0, so can take w = 1
F3wa := Evaluate(F3w, [u,v,1,w]); p3wa := Evaluate(p3w, [u,v,1,w]);
// B: u = v = 0

special_fiber(F3wa, p3wa);
// --> [ <2, [ w, u^2 + v^2 + v ]>, <2, [ v, u ]> ]
// C', B
// only need to check point u = v = w = 0 for regularity (other points already in other chart)
check_reg(F3wa, [u, v, w]);
// --> [ 0, 1, 0 ], so regular

// back to first chart. Blow up (u, v, w)
F4, p4 := blow_up(F3va, p3va, [u, v, w]);
// coordinates (u : v : w), z
special_fiber(F4, p4);
// --> [ <6, [ z, u + w ]>, <2, [ w, u ]>, <2, [ v, u^2 + w^3*z + w^2 ]> ]
// new D, A, C'
// replace u by u - w to get new component D aligned
F4a := Evaluate(F4, [u-w,v,w,z]); p4a := Evaluate(p4, [u-w,v,w,z]);
while true do FF := subs(p4a, F4a); if FF eq F4a then break; end if; F4a := FF; end while;
special_fiber(F4a, p4a);
// --> [ <6, [ z, u ]>, <2, [ w, u ]>, <2, [ v, u^2 + w^3*z ]> ]
// D, A, C'
check_reg(F4a, [u, z]);
// --> [ v^2*w + w^3, 0 ], so non-reg. only at w = 0 (inters. with A), v + w = 0
// can take v = 1
F4b := Evaluate(F4a, [u,1,w,v]); p4b := Evaluate(p4a, [u,1,w,v]);
special_fiber(F4b, p4b);
// --> [ <2, [ w, u ]>, <6, [ v, u ]> ]
// D, A

// blow up intersection of A and D
F5_1, p5_1 := blow_up(F4b, p4b, [u, v, w]);
// coordinates (u : v : w), z
special_fiber(F5_1, p5_1);
// --> [ <4, [ z, u^2 + v*w ]>, <2, [ w, u ]>, <6, [ v, u ]> ]
// new E, A, D
P4F2!Coefficient(F5_1, z, 0);
// --> u^2 + v*w, smooth conic --> regular along E

// now look at the other point (u = v+w = z = 0)
// with v = 1, z --> v: u = v = 0, w = 1
// shift w by 1
F4c := Evaluate(F4b, [u,v,w-1,z]); p4c := Evaluate(p4b, [u,v,w-1,z]);
while true do FF := subs(p4c, F4c); if FF eq F4c then break; end if; F4c := FF; end while;
special_fiber(F4c, p4c);
// --> [ <6, [ v, u ]> ]
// only see D here
F5, p5 := blow_up(F4c, p4c, [u, v, w]);
// coordinates (u : v : w), z
special_fiber(F5, p5);
// --> [ <6, [ z, u + v ]>, <6, [ v, u ]> ]
// new F, D
// shift
F5a := Evaluate(F5, [u-v,v,w,z]); p5a := Evaluate(p5, [u-v,v,w,z]);
special_fiber(F5a, p5a);
// --> [ <6, [ z, u ]>, <6, [ v, u ]> ]
// F, D
check_reg(F5a, [u, z]);
// --> [ v^3 + v^2*w + v*w^2, 0 ], non-reg. if v = 0 or v^2 + v*w + w^2 = 0
// for interesting part, can take w = 1
F5b := Evaluate(F5a, [u,v,1,w]); p5b := Evaluate(p5a, [u,v,1,w]);
special_fiber(F5b, p5b);
// --> [ <6, [ w, u ]>, <6, [ v, u ]> ]
// F, D

// first point is intersection of D and F
F6_1, p6_1 := blow_up(F5b, p5b, [u, v, w]);
// coordinates (u : v : w), z
special_fiber(F6_1, p6_1);
// --> [ <6, [ z, u^2 + v*w ]>, <6, [ w, u ]>, <6, [ v, u ]> ]
// new G, F, D
P4F2!Coefficient(F6_1, z, 0);
// --> u^2 + v*w, smooth conic --> regular

// now we have a pair of points over F_4
// base-change to K / F_4, where K is 3rd cyclotomic field
K := NumberField(x^2 + x + 1);
OK := Integers(K);
a := OK!K.1;
pr2 := Decomposition(OK, 2)[1,1];
F4, red := ResidueClassField(OK, pr2);
P4K<U,V,W,Z> := PolynomialRing(OK, 4);
P4F4 := PolynomialRing(F4, 4);
AssignNames(~P4F4, ["U","V","W","Z"]);
redP := hom<P4K -> P4F4 | red, [P4F4.j : j in [1..4]]>;

F5_K := P4K!F5b; p5_K := P4K!p5b;
// shift: v --> v - a
F5_Kc := Evaluate(F5_K, [U,V-a,W,Z]); p5_Kc := Evaluate(p5_K, [U,V-a,W,Z]);
Factorization(p5_Kc); // only W is relevant, mult. = 3
// replace factors 2 by p5_Kc
cs, ms := CoefficientsAndMonomials(F5_Kc);
FF := &+[ExactQuotient(cs[i], OK!2^val)*p5_Kc^val*ms[i] where val := Valuation(cs[i], pr2)
          : i in [1..#cs]];
F5_Kc := FF;

Factorization(redP(Evaluate(F5_Kc, [U,V,0,Z])));
// --> [ <U, 2> ], so have mult. 6  U = W = 0; this is F

// blow up (U, V, W)
md := Min([Degree(m) : m in Monomials(F5_Kc)]);
F6_K := ExactQuotient(Evaluate(F5_Kc, [U*Z, V*Z, W*Z, 0]), Z^md);
p6_K := W^3*Z^3; // ignore irrelevant factors
Factorization(redP(Evaluate(F6_K, [U,V,W,0])));
// --> [ <U^2 + F4.1^2*V*W + W^2, 1> ] ; new H1, smooth conic --> regular, mult. 3
Factorization(redP(Evaluate(F6_K, [U,V,0,Z])));
// --> [ <U, 2> ] ; this is F

// plus the conjugate component H2

// We obtain the following configuration:
/*
         E
         |
     A---+-----------2
         |
         |     C'              G
         |     |               |
      D--+-----+---------------+---6  H1  H2
         |     |               |      |   |
         |     |            F--+------+---+--6
         4     |               |      |   |
            B--+---------2     6      |<->| Frob
               |                      |   |
               |                      3   3
               2
*/
// Note that B is a (-1)-curve and can be contracted.
// Then every component is a (-2)-curve except C with C^2 = -3
// We find N-U type [III_2^*] (the very last in the paper!)

// The multiplicities and the intersection matrix
m := Vector([2, 2, 6, 4, 6, 6, 3, 3]);
// rows/columns indexed by (A, C', D, E, F, G, H1, H2)
//             A   C'  D   E   F   G  H1  H2
M := Matrix([[-2,  0,  0,  1,  0,  0,  0,  0], // A
             [ 0, -3,  1,  0,  0,  0,  0,  0], // C'
             [ 0,  1, -2,  1,  0,  1,  0,  0], // D
             [ 1,  0,  1, -2,  0,  0,  0,  0], // E
             [ 0,  0,  0,  0, -2,  1,  1,  1], // F
             [ 0,  0,  1,  0,  1, -2,  0,  0], // G
             [ 0,  0,  0,  0,  1,  0, -2,  0], // H1
             [ 0,  0,  0,  0,  1,  0,  0, -2]]); // H2
assert m*M eq Parent(m)!0;

FA := FreeAbelianGroup(Ncols(m));
// Frobenius swaps the last two entries
frob := hom<FA -> FA | [FA.1, FA.2, FA.3, FA.4, FA.5, FA.6, FA.8, FA.7]>;
// Set up geometric component group
// as quotient of the kernel of the degree map by the subgroup generated by the rows of M
ZA := FreeAbelianGroup(1);
deg := hom<FA -> ZA | [m[j]*ZA.1 : j in [1..8]]>;
TG, qmap := quo<Kernel(deg) | sub<FA | [FA!Eltseq(M[j]) : j in [1..8]]>>;
Invariants(TG);
// --> [], so geometric component group is trivial!
